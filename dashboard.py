# -*- coding: utf-8 -*-
"""dashboard.ipynb

Automatically generated by Colab.

Original file is located at
    https://colab.research.google.com/drive/1_t0vtW_spI_WklrrOJm1J5tnO_K3m925
"""

import streamlit as st
import pandas as pd
import folium
from streamlit_folium import st_folium
from folium.plugins import HeatMap
import matplotlib.pyplot as plt
from twilio.rest import Client

# Twilio SMS alert helper function
def send_sms_alert(body, to_number):
    account_sid = st.secrets["twilio_account_sid"]
    auth_token = st.secrets["twilio_auth_token"]
    from_number = st.secrets["twilio_from_number"]
    client = Client(account_sid, auth_token)
    message = client.messages.create(body=body, from_=from_number, to=to_number)
    return message.sid

@st.cache_data
def load_data():
    df = pd.read_csv('processed_pollution_data.csv')
    df['Timestamp'] = pd.to_datetime(df['Timestamp'])
    return df

df = load_data()

st.title("EnviroScan: Andhra Pradesh Pollution Dashboard")

# Sidebar for filters and alerts settings
with st.sidebar:
    st.header("Filters")
    cities = df['city'].unique().tolist()
    selected_cities = st.multiselect("Select cities:", cities, default=cities)
    min_date = df['Timestamp'].min().date()
    max_date = df['Timestamp'].max().date()
    date_range = st.date_input("Select date range:", [min_date, max_date])

    # SMS Alert settings
    st.header("SMS Alerts")
    phone_number = st.text_input("Phone number to receive SMS alerts (+CountryCode Number)", "")
    enable_sms = st.checkbox("Enable SMS alerts")

# Filter data with sidebar inputs
df_filtered = df[
    (df['city'].isin(selected_cities)) &
    (df['Timestamp'].dt.date >= date_range[0]) &
    (df['Timestamp'].dt.date <= date_range[1])
]

st.write(f"Records selected: {len(df_filtered)}")

# Using tabs for charts and maps
tab1, tab2, tab3 = st.tabs(["Pollution Trends", "Source Distribution", "Map & Alerts"])

with tab1:
    pollutants = ['PM2.5', 'PM10', 'NO2', 'SO2', 'CO', 'Ozone']
    pollutant = st.selectbox("Pollutant for trend:", pollutants)
    trend_data = df_filtered.groupby('Timestamp')[pollutant].mean().reset_index()
    st.line_chart(trend_data.rename(columns={pollutant:'value'}).set_index('Timestamp')['value'])

with tab2:
    sources = df_filtered['source'].value_counts()
    labels = sources.index.tolist()
    sizes = sources.values.tolist()
    # Explode all except dominant category (adjust if your data varies)
    explode = [0.08 if size < 0.2 * sum(sizes) else 0 for size in sizes]
    colors = ['#337ab7', '#ff9800', '#4caf50', '#e91e63', '#8bc34a', '#888888']

    fig, ax = plt.subplots(figsize=(7, 7))
    wedges, texts, autotexts = ax.pie(
        sizes, labels=labels, autopct='%1.1f%%',
        startangle=90, explode=explode, colors=colors[:len(labels)],
        textprops={'fontsize': 12}, pctdistance=0.82
    )
    # Move small label texts outward for visibility
    for i, txt in enumerate(texts):
        if sizes[i] < 0.15 * sum(sizes):
            txt.set_position((1.3 * txt.get_position()[0], 1.3 * txt.get_position()[1]))

    plt.title('Source Distribution')
    ax.axis('equal')
    plt.legend(labels, loc='center left', bbox_to_anchor=(1, 0.5))
    st.pyplot(fig)

with tab3:
    thresholds = {'PM2.5': 60, 'PM10': 100, 'NO2': 40, 'SO2': 20, 'CO': 10, 'Ozone': 70}
    alerts = []
    alert_messages = []
    for pol, thr in thresholds.items():
        if pol in df_filtered.columns:
            max_val = df_filtered[pol].max()
            if max_val > thr:
                msg = f"⚠️ {pol} level high! Max: {max_val:.2f} > threshold {thr}"
                alerts.append(msg)
                alert_messages.append(f"{pol}: {max_val:.2f}")

    if alerts:
        st.warning("\n".join(alerts))
        if enable_sms and phone_number.strip():
            sms_body = f"EnviroScan Alert:\n" + "\n".join(alert_messages)
            try:
                message_sid = send_sms_alert(sms_body, phone_number)
                st.success(f"SMS alert sent (SID: {message_sid}) to {phone_number}")
            except Exception as e:
                st.error(f"Failed to send SMS alert: {e}")
    else:
        st.success("All pollutant levels within safe limits.")

    def get_color(source):
        return {'Vehicular':'blue', 'Industrial':'red', 'Agricultural':'green', 'Burning':'orange', 'Unknown':'gray'}.get(source, 'black')

    if not df_filtered.empty:
        m = folium.Map(location=[df_filtered['latitude'].mean(), df_filtered['longitude'].mean()], zoom_start=7)
        for _, row in df_filtered.iterrows():
            folium.CircleMarker(
                location=[row['latitude'], row['longitude']],
                radius=6,
                color=get_color(row['source']),
                fill=True,
                fill_opacity=0.7,
                popup=f"{row['city']}, Source: {row['source']}, {pollutant}: {row[pollutant]:.1f}"
            ).add_to(m)
        heat_data = df_filtered[['latitude', 'longitude', pollutant]].dropna().values.tolist()
        HeatMap(heat_data).add_to(m)
        st_folium(m, width=800, height=500)
    else:
        st.info("No data available for map display.")

# Download filtered data
csv_bytes = df_filtered.to_csv(index=False).encode('utf-8')
st.download_button(
    label='Download filtered data as CSV',
    data=csv_bytes,
    file_name='pollution_report.csv',
    mime='text/csv',
)
